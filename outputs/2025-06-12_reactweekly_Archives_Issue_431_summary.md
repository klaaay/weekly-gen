### [React 状态周报第 429 期：2025 年 5 月 14 日](https://react.statuscode.com/issues/429)

**原文标题**: [React Status Issue 429: May 14, 2025](https://react.statuscode.com/issues/429)

- 📅 React Status 将于 5 月 28 日恢复发布，编辑 Peter Cooper 将参加 Google I/O。  
- ⚡ tscircuit：使用 React 构建电子项目，通过 React 方法设计电路板。  
- 🎓 Frontend Masters 提供现代 React 课程，涵盖 React 19+ 新特性如服务器组件和 Suspense。  
- 📖 Dan Abramov 解释如何将服务器组件预渲染为静态资源并通过 CDN 免费提供。  
- 🔄 TanStack Query 计划合并多个方法为 `query()` 和 `infiniteQuery()`，简化数据获取。  
- 💬 Reddit 讨论 React 在 2025 年的前景，社区意见不一。  
- 🛠️ Vercel 推出 AI 爬虫过滤器，支持一键配置。  
- 🌦️ 使用 GitHub Copilot 代理模式构建天气应用，展示其强大功能。  
- 💳 Clerk Billing 提供订阅管理方案，无需自定义支付代码。  
- 📢 多篇文章探讨 React Context、React Query 的乐观更新、依赖反转等话题。  
- 🛠️ 工具更新：React Chrono 2.7、Bippy、Basecoat、React Query Builder 8.7 等。  
- 📢 其他新闻：V8 引入显式资源管理、Parcel v2.15.0 发布、npm 包最佳实践等。

---

### [过度反应 —— Dan Abramov 的博客](https://overreacted.io/)

**原文标题**: [overreacted — A blog by Dan Abramov](https://overreacted.io/)

这是一系列关于 React、前端开发和个人技术思考的文章标题和简短描述，涵盖技术细节、开发原则和个人经验。

- 🛠️ "Suppressions of Suppressions" - 关于代码检查的讨论。  
- 💼 "I'm Doing a Little Consulting" - 个人近况更新。  
- 🔄 "How Imports Work in RSC" - 分层模块系统。  
- 🖥️ "RSC for LISP Developers" - 模块引用机制。  
- 📡 "Progressive JSON" - 流式传输的局限性。  
- 📦 "Why Does RSC Integrate with a Bundler?" - 模块序列化的复杂性。  
- 🔗 "One Roundtrip Per Navigation" - HTML、GraphQL 和 RSC 的共同点。  
- 🌐 "Static as a Server" - 静态站点的现代应用。  
- 🏝️ "RSC for Astro Developers" - 分形岛屿架构。  
- 🏷️ "Functional HTML" - 双向标签设计。  
- 🌍 "What Does 'use client' Do?" - 客户端与服务器的界限。  
- 🧩 "Impossible Components" - 跨栈组合的挑战。  
- 🔌 "JSX Over The Wire" - API 设计的反转思路。  
- 💻 "React for Two Computers" - 同源双端协作。  
- 📊 "The Two Reacts" - UI 与数据和状态的关系。  
- 🔗 "A Chain Reaction" - 语言限制对世界认知的影响。  
- ⚠️ "npm audit: Broken by Design" - 漏洞报告的问题。  
- ⚡ "Before You memo()" - 自然的渲染优化。  
- 🏚️ "The WET Codebase" - 代码重复的代价。  
- 👋 "Goodbye, Clean Code" - 清洁代码的适时放手。  
- 📅 "My Decade in Review" - 个人十年回顾。  
- 🧭 "What Are the React Team Principles?" - UI 优先于 API。  
- 🔤 "On let vs const" - 变量声明的选择。  
- 🧠 "What Is JavaScript Made Of?" - JavaScript 的本质。  
- 🛠️ "How Does the Development Mode Work?" - 开发模式的约定。  
- 🌯 "Algebraic Effects for the Rest of Us" - 代数效应的通俗解释。  
- 🎤 "Preparing for a Tech Talk, Part 3: Content" - 技术演讲的内容准备。  
- 📖 "Name It, and They Will Come" - 故事驱动的变革。  
- 🛡️ "Writing Resilient Components" - 健壮组件的四个原则。  
- 📚 "A Complete Guide to useEffect" - 副作用与数据流。  
- 🆚 "How Are Function Components Different from Classes?" - 函数组件与类的区别。  
- 😴 "Coping with Feedback" - 处理反馈的挑战。  
- 🏗️ "Fix Like No One’s Watching" - 另一种技术债务。  
- ⏱️ "Making setInterval Declarative with React Hooks" - 声明式定时器。  
- ⚛️ "React as a UI Runtime" - React 编程模型详解。  
- ❓ "Why Isn’t X a Hook?" - Hook 设计的边界。  
- 🐞 "The 'Bug-O' Notation" - API 的缺陷复杂度。  
- 🎤 "Preparing for a Tech Talk, Part 2: What, Why, and How" - 演讲的核心问题。  
- 🧩 "The Elements of UI Engineering" - UI 工程的难点。  
- ❓ "Things I Don’t Know as of 2018" - 知识空白的坦然面对。  
- 🎤 "Preparing for a Tech Talk, Part 1: Motivation" - 演讲灵感的来源。  
- 🔄 "Why Do React Hooks Rely on Call Order?" - 调用顺序的重要性。  
- 🔄 "Optimized for Change" - 优秀 API 的特质。  
- ❓ "How Does setState Know What to Do?" - 依赖注入的隐式机制。  
- 🎄 "My Wishlist for Hot Reloading" - 热重载的期望。  
- 🔒 "Why Do React Elements Have a $$typeof Property?" - 安全相关的设计。  
- 🆚 "How Does React Tell a Class from a Function?" - 类与函数的区分。  
- ❓ "Why Do We Write super(props)?" - 构造函数中的 super 调用。

---

### [服务端组件 – React](https://react.dev/reference/rsc/server-components)

**原文标题**: [Server Components – React](https://react.dev/reference/rsc/server-components)

React Server Components 是一种新型组件，可在打包前在独立于客户端应用或 SSR 服务器的环境中预先渲染，支持构建时或按请求运行。  

- 🚀 **Server Components 概述**  
  - 在构建时或请求时运行，独立于客户端环境  
  - 可访问文件系统或静态内容，无需实时服务器  

- ⚡ **无服务器的 Server Components**  
  - 构建时读取静态数据（如 CMS），减少客户端捆绑包体积  
  - 示例：直接渲染 Markdown 内容，无需客户端加载库  

- 🔄 **带服务器的 Server Components**  
  - 请求时动态获取数据，避免客户端瀑布式请求  
  - 数据与 JSX 通过 props 传递至客户端组件  

- 💡 **交互性增强**  
  - Server Components 不可用 `useState`，需与客户端组件（`"use client"`）组合  
  - 示例：可折叠面板通过客户端组件实现状态切换  

- ⏳ **异步组件支持**  
  - 使用 `async/await` 在渲染中暂停，支持跨服务端/客户端边界流式传输  
  - 服务端启动 Promise，客户端通过 `use` 恢复渲染  

- ⚠️ **注意事项**  
  - 底层 API 可能在小版本间变动，建议锁定 React 版本或使用 Canary 发布  
  - 无 `"use server"` 指令，该指令仅用于 Server Functions  

- 🌐 **架构优势**  
  - 结合 MPA 的请求/响应模型与 SPA 的交互性，优化性能与体验

---

### [RSC 中的导入机制解析——过度反应版](https://overreacted.io/how-imports-work-in-rsc/)

**原文标题**: [How Imports Work in RSC — overreacted](https://overreacted.io/how-imports-work-in-rsc/)

React Server Components（RSC）是一种编程范式，允许开发者将客户端/服务器应用表达为跨越两个环境的单一程序。RSC 扩展了模块系统（`import` 和 `export` 关键字），通过新的语义让开发者控制前端/后端的分离。

- 🚀 **RSC 概述**：RSC 是一种编程范式，允许开发者将客户端/服务器应用表达为跨越两个环境的单一程序。
- 🔗 **模块系统扩展**：RSC 扩展了 `import` 和 `export` 关键字，让开发者控制前端/后端的分离。
- 📌 **分割点标记**：`'use client'` 和 `'use server'` 指令标记了前端和后端的“分割点”。
- 🔍 **模块系统基础**：模块系统帮助开发者将复杂程序分解为更小的部分，便于管理和重用代码。
- 📂 **JavaScript 模块**：JavaScript 模块系统通过 `import` 和 `export` 关键字工作，确保模块是单例的，无论被导入多少次，模块代码只执行一次。
- 🔄 **前后端代码共享**：传统上，前后端代码是两个独立的程序，运行在不同的计算机上，但 RSC 允许更灵活的代码共享。
- ⚠️ **构建失败的好处**：当代码被错误地导入到不适合的环境时，构建失败可以帮助开发者及早发现问题。
- 🔒 **服务器专用代码**：通过 `server-only` 标记，可以防止服务器专用代码被意外导入到前端代码中。
- 🖥️ **客户端专用代码**：类似地，`client-only` 标记可以防止客户端专用代码被意外导入到后端代码中。
- 🚪 **RSC 的“门”机制**：`'use client'` 和 `'use server'` 指令允许前后端代码相互引用，而不需要将代码导入到当前环境。
- 🔗 **RSC 的优势**：RSC 提供了一种自然的方式来解决前后端代码共享时的冲突，同时保持了模块系统的独立性和灵活性。

---

### [渐进式 JSON —— 过度反应](https://overreacted.io/progressive-json/)

**原文标题**: [Progressive JSON — overreacted](https://overreacted.io/progressive-json/)

渐进式 JSON 是一种通过流式传输和按需加载数据来优化 JSON 处理效率的技术，类似于渐进式 JPEG 的加载方式。以下是关键点总结：

- 🌐 **传统 JSON 传输问题**：客户端必须等待整个 JSON 加载完成才能解析，导致延迟，尤其是当部分数据（如评论）生成较慢时。
- 🔄 **流式 JSON 解析**：允许逐步解析不完整的 JSON，但存在数据结构不完整、字段缺失的问题，难以在客户端直接使用。
- 🌳 **广度优先传输**：通过占位符（如`$1`）和 Promise 逐步填充数据，客户端可以部分处理已加载内容，未加载部分显示为 Promise。
- 📦 **数据分块与内联**：服务器根据数据生成速度动态分块传输，平衡效率与完整性，避免过度流式化导致冗余。
- 🔄 **数据去重与循环引用**：通过“外联”重复对象减少传输量，并支持循环引用的序列化。
- ⚛️ **React 服务端组件（RSC）应用**：React 利用渐进式 JSON 流传输组件树，结合`<Suspense>`控制 UI 加载状态，实现数据与渲染解耦。
- 🎯 **核心优势**：打破串行延迟，允许客户端尽早处理可用数据，同时通过设计加载状态（如骨架屏）提升用户体验。
- 💡 **挑战与改进**：需客户端兼容不完整数据（如 Promise），并设计合理的分块策略（如关键内容优先内联）。

---

### [渐进式 JPEG：它是什么及如何提升网站性能](https://www.hostinger.com/uk/tutorials/what-is-progressive-jpeg-images)

**原文标题**: [Progressive JPEG: What Is It & How It Can Improve Website Performance](https://www.hostinger.com/uk/tutorials/what-is-progressive-jpeg-images)

渐进式 JPEG 图像通过分阶段加载提升网站性能，相比基线 JPEG 能更快呈现完整画面并减少资源占用。以下是关键步骤和工具指南：

- 🔍 **渐进式 JPEG 与基线 JPEG 的区别**  
  基线 JPEG 逐行加载（顶部到底部），而渐进式 JPEG 先显示模糊全图再逐渐清晰。

- ⚡ **渐进式 JPEG 的优势**  
  提升用户体验（快速预览全图）、减少带宽和磁盘占用，主流浏览器均支持（需注意旧版 IE 兼容性）。

- 🛠️ **转换步骤**  
  1. **分析现有图片**：用 WebPageTest 检测基线 JPEG；  
  2. **转换工具推荐**：Optimizilla（在线压缩 + 转换）或 RIOT（Windows 端多功能优化）；  
  3. **替换图片**：通过文件管理器或 FTP 更新网站图片，保持同名避免技术问题。

- 📌 **注意事项**  
  转换时建议保持画质≥85%，转换后需重新测试网站性能确保无基线 JPEG 残留。

---

### [为什么 RSC 要与打包工具集成？——过度反应](https://overreacted.io/why-does-rsc-integrate-with-a-bundler/)

**原文标题**: [Why Does RSC Integrate with a Bundler? — overreacted](https://overreacted.io/why-does-rsc-integrate-with-a-bundler/)

React Server Components（RSC）通过与打包工具集成，实现了服务器和客户端之间的代码与数据高效序列化与反序列化，优化了模块加载性能。

- 🧩 RSC 是一种编程范式，将服务器/客户端应用作为跨两个运行时的单一程序，核心包含序列化（`react-server`）和反序列化（`react-client`）工具。  
- 📦 RSC 未直接发布到 npm，因其依赖模块系统集成，需处理代码（如组件逻辑）而不仅是数据的传输。  
- 🔄 序列化模块时，RSC 避免重复发送代码字符串，转而引用静态 JS 资源路径（如`/src/client.js#Counter`），类似`<script>`标签逻辑。  
- ⚡ 直接按需加载模块会导致网络瀑布问题，因此 RSC 集成打包工具（如 Parcel、Webpack）预构建`'use client'`文件，生成优化后的代码块。  
- 🔌 打包工具绑定提供三阶段支持：构建时生成代码块、服务器端序列化模块引用（如`'chunk123.js#Counter'`）、客户端动态加载模块。  
- 📡 底层 API 通过`serialize`（服务器）和`deserialize`（客户端）实现树结构的传输与重建，框架（如 Next.js）基于此封装高级功能。  
- 🛠️ 开发者可通过 Parcel 等实现体验 RSC 底层流程，实际 API 名称可能因打包工具而异（如`renderRSC`/`fetchRSC`）。

---

### [LISP 开发者指南：RSC 详解 — 过度反应剖析](https://overreacted.io/rsc-for-lisp-developers/)

**原文标题**: [RSC for LISP Developers — overreacted](https://overreacted.io/rsc-for-lisp-developers/)

LISP 的核心思想是“代码即数据，数据即代码”，这一理念在 LISP 的文化和语法中得到了充分体现。通过引用（quoting）机制，LISP 可以将代码作为数据处理，并在需要时通过 eval 函数执行。React 服务器组件（RSC）借鉴了这一思想，允许在服务器端引用客户端代码，但实现方式和灵活性有所不同。

- 🧩 LISP 中的“代码即数据”理念通过引用（quoting）机制实现，例如`'(+ 2 2)`返回未执行的代码，而`(eval '(+ 2 2))`则执行代码并返回结果 4。
  
- 🌐 在 Web 应用中，服务器生成客户端代码（如 HTML 和 JavaScript）并发送给客户端，这与 LISP 中的引用机制类似。
  
- ⚛️ React 服务器组件（RSC）通过`'use client'`指令允许服务器端引用客户端代码，但不直接执行，而是生成一个用于加载该模块的引用标识。
  
- 🔄 RSC 的代码最终会在客户端通过`<script>`标签加载并执行，实现了服务器和客户端代码的模块化组合。
  
- 🚀 RSC 的优势在于能够在单个请求/响应周期内组合服务器和客户端代码，并支持渐进式流式传输。
  
- 🤔 与 LISP 的引用机制相比，RSC 的功能较为有限，缺乏元编程能力，无法在运行时转换或内省代码。
  
- 📚 文章提到 LISP 中有许多跨环境组合代码的解决方案，如 Electric，并希望看到更多面向 JavaScript 开发者的相关解释和新思路。

---

### [我在做点咨询——反应过度了](https://overreacted.io/im-doing-a-little-consulting/)

**原文标题**: [I'm Doing a Little Consulting — overreacted](https://overreacted.io/im-doing-a-little-consulting/)

作者离开 Meta 后加入 Bluesky 近两年，专注 React Native 开发与应用优化，现已离职休整。目前处于职业探索期，不确定未来方向，重启博客主要撰写 React Server Components 相关内容。现提供付费技术咨询（React/React Native 领域），通过 1 对 1 通话协助解决架构、性能等技术问题，适合技术领导者或积极学习者。  

- 🚪 离开 Meta 后加入 Bluesky 近两年，现离职休整  
- 🤔 职业空窗期，对未来技术方向感到迷茫  
- ✍️ 重启博客，聚焦 React Server Components 技术分享  
- 💡 提供 React/React Native 技术咨询（付费 1 对 1 通话）  
- 📧 咨询联系：[email protected]

---

### [❄️ 冻结传统架构 · reactwg/react-native-new-architecture · 讨论 #290 · GitHub](https://github.com/reactwg/react-native-new-architecture/discussions/290)

**原文标题**: [❄️ Freezing the Legacy Architecture · reactwg/react-native-new-architecture · Discussion #290 · GitHub](https://github.com/reactwg/react-native-new-architecture/discussions/290)

React Native 官方宣布自 2025 年 6 月 2 日起冻结旧架构（Legacy Architecture）的开发和支持，全面转向新架构（New Architecture）。以下是关键点总结：

- 🚫 **冻结旧架构**：从 6 月 2 日起，不再接受针对旧架构的 PR，也不再为其开发新功能或修复非关键问题。  
- 🔒 **例外情况**：仅接受安全修复和导致旧架构完全无法使用的严重问题修复。  
- 🛠 **开发重心转移**：所有新功能和优化将仅针对新架构，旧架构代码库进入维护冻结状态。  
- ⚠️ **测试调整**：从 React Native 0.81 开始，发布时将不再对旧架构进行正式测试，仅以“尽力而为”方式处理。  
- 📢 **迁移建议**：  
  - 📚 **库维护者**：需逐步迁移至新架构的 Native Modules/Components，尽管互操作层（Interop Layer）暂未弃用，但未来会被移除。  
  - 📱 **应用开发者**：建议启用新架构，检查并迁移本地模块或第三方库依赖。  
- ℹ️ **兼容性提示**：React Native 0.80+ 会通过日志警告标识不兼容新架构的代码，帮助开发者排查问题。  
- 🔗 **背景信息**：新架构自 2024 年 10 月（0.76 版本）起稳定，Expo SDK 53（2025 年 4 月）也推荐全量采用。  

（注：部分讨论涉及互操作层的长期支持问题，官方确认其暂不弃用但未来会移除。）

---

### [关于新架构·React Native](https://reactnative.dev/architecture/landing-page)

**原文标题**: [About the New Architecture · React Native](https://reactnative.dev/architecture/landing-page)

React Native 团队自 2018 年起重新设计了核心架构，以提升开发体验，新架构已在 Meta 的生产环境中验证，并从 0.68 版本开始逐步开放，现已成为默认选项。新架构解决了旧架构的固有限制，支持同步布局、并发渲染等新特性，并通过 JSI 技术优化了原生与 JavaScript 的交互性能。

- 🚀 **新架构概述**：自 2018 年启动，2024 年成熟，现为 React Native 默认架构，提升开发体验与性能。  
- 🔄 **同步布局与效果**：避免视觉跳跃，通过`useLayoutEffect`实现同步测量与布局更新。  
- ⚡ **并发渲染支持**：兼容 React 18 特性，如 Suspense、Transitions，并自动批量减少渲染。  
- 📊 **性能优化示例**：自动批处理减少渲染次数，过渡标记优化 UI 响应。  
- 🔗 **快速原生交互**：JSI 取代异步桥接，直接调用原生方法，提升如实时相机库的性能。  
- 🛠 **启用新架构**：需代码适配新特性，但未来将支持更多能力（如 Web 对齐）。  
- ❓ **是否采用**：0.76 起默认启用，问题可反馈；支持通过配置回退旧架构（Android/iOS）。  
- 📅 **持续更新**：团队活跃开发中，可通过讨论库参与贡献。

---

### [React 果酱](https://reactjam.com/)

**原文标题**: [React Jam](https://reactjam.com/)

React Jam 是一个为期 10 天的在线活动，React 开发者齐聚一堂，使用 React 技术开发游戏。活动鼓励开发者展示技能、尝试新想法，并与社区互动。今年的主题是“不要相信任何人”，要求游戏围绕欺骗、误导或隐藏动机展开。活动设有多个奖项，包括最佳游戏和多人游戏挑战奖，并提供丰厚的奖金。参与者可以单独或组队参赛，使用各种工具和资源，包括 AI 辅助开发。提交的游戏需符合主题，且不能进行网络请求。活动结束后，优胜者将在社交平台上公布。

- 🎮 **React Jam 简介**：为期 10 天的在线活动，React 开发者共同开发游戏。
- 🏆 **奖项设置**：最佳游戏奖（趣味性、主题契合度、呈现效果）和多人游戏挑战奖（最高游戏时长）。
- 💡 **主题要求**：游戏需围绕“不要相信任何人”展开，设计欺骗、误导或隐藏动机的元素。
- 👥 **参与方式**：可单独或组队参赛，允许使用 AI 辅助开发。
- 🛠️ **开发工具**：可使用 React、React Pixi、React Three Fiber 等，支持 TypeScript 和 WebAssembly。
- 📦 **提交要求**：游戏需为自包含包，不超过 10MB，且不能进行网络请求。
- 📅 **时间安排**：活动从 5 月 16 日开始，5 月 26 日结束，提交截止时间为 5 月 26 日下午 1 点 UTC。
- 🎨 **资源推荐**：提供艺术、音频、字体等资源的推荐列表，需遵守版权规定。
- 📢 **宣传与赞助**：鼓励在社交媒体上分享进展，欢迎公司赞助。
- 📜 **法律声明**：参赛作品归开发者所有，活动方有权用于宣传。

---

### [React Jam 获胜者！](https://reactjam.com/winners)

**原文标题**: [React Jam Winners!](https://reactjam.com/winners)

2025 年春季 React 游戏大赛以"信任无人"为主题，展示了多款创意游戏作品，所有游戏均使用 React 开发且体积小于 10MB。

- 🏆 **最佳游戏**  
  - *Cloudy Contacts*：间谍主题任务游戏，扮演特工寻找联系人（桌面端，评分：趣味 4.0/主题 5.0/呈现 4.33）  
  - *Hackware*：多人黑客对战游戏，通过攻击玩家升级（评分：趣味 3.67/主题 5.0/呈现 3.67）  
  - *Other Word*：社交推理游戏，识别伪装者描述的秘密词汇（评分：趣味 3.5/主题 4.5/呈现 4.0）  
  - *Tyche's Hand*：黑暗故事背景的 21 点游戏（评分：趣味 4.0/主题 3.67/呈现 4.33）  

- 🎮 **多人挑战赛优胜**  
  - *Hackware*（最高在线时长）  
  - *Untrusted Waters*：策略战舰对战游戏，含欺骗机制  
  - *Maze Chase*：红蓝追逐迷宫游戏，含旁观者干扰机制  

- 🌟 **荣誉提名**  
  - *Zodiac Duality*：平衡阴阳能量的星座收集游戏  
  - *The Whispering Glass*：1920 年代酒保间谍模拟游戏  
  - *Paw & Order*：猫咪侦探破案游戏  
  - *4Down*：多人卡牌虚张声势游戏  

- 🕵️ **其他参赛作品**  
  - *100 Men vs Gorilla*：战略欺骗游戏  
  - *Replicant Bounty Hunter*：识别伪装者  
  - *Dashcore*：几何冲刺风格平台游戏  
  - *City of Deceit*：类似 Citadels 的桌游  

注：所有游戏均围绕"不信任"主题设计，包含社交推理、策略欺骗等核心机制。大赛由 React Jam 主办，历届赛事链接已附在文末。

---

### [打造霓虹城：使用 React Native、Reanimated 和 Expo 开发的快节奏手游](https://expo.dev/blog/mobile-game-development-with-expo)

**原文标题**: [Building NeonCity: A fast-paced mobile game made with React Native, Reanimated, and Expo](https://expo.dev/blog/mobile-game-development-with-expo)

Expo 是一个提供应用开发工具和服务的平台，包含文档、博客、支持等资源，同时强调社区互动和法律合规。

- 📝 **文档与资源** - 提供详细的开发文档、博客和更新日志。  
- 🛠️ **开发工具** - 包括 Expo CLI、EAS（Expo 应用服务）、Expo Go 和 Snack 等工具。  
- 🌐 **社区支持** - 提供 Discord 社区、GitHub 互动和新闻通讯。  
- 🏢 **公司信息** - 包含主页、定价、客户案例和招聘信息。  
- ⚖️ **法律与合规** - 涵盖服务条款、隐私政策、安全合规和社区准则。  
- ©️ **版权声明** - 版权归 650 Industries, Inc. 所有。

---

### [醒来吧，混音！| 混音](https://remix.run/blog/wake-up-remix)

**原文标题**: [Wake up, Remix! | Remix](https://remix.run/blog/wake-up-remix)

概述总结  
Remix 团队宣布结束“休眠”，推出全新方向的 Remix v3，基于 React Router v7 的成熟技术，并强调简化、模块化和贴近 Web 平台的设计理念。  

- 🚀 **Remix 结束休眠**：团队宣布结束 Remix 的“休眠”状态，推出全新版本的 Remix v3。  
- 🔄 **React Router v7 的成熟**：React Router v7 已成为强大且稳定的基础，支持 RSC（服务器组件）和服务器路由，被多家大型企业采用。  
- 🛠️ **Remix v3 的新方向**：Remix v3 将是一个模块化工具包，注重简洁性、性能和贴近 Web 平台，不依赖关键第三方库（如 React）。  
- 🌐 **基于 Web API**：新版本将基于 Web API 和 JavaScript，减少上下文切换，提升开发体验。  
- 📦 **零依赖原则**：强调减少依赖，设计可组合的抽象模块，每个模块独立且可替换。  
- 🧩 **模块化与组合性**：提倡单用途、可替换的抽象模块，同时提供统一的工具箱（`remix`）便于使用和学习。  
- 🤖 **AI 优先开发**：优化代码、文档和工具链以适应 LLM（大语言模型），并在产品中集成模型能力。  
- 🎉 **社区参与**：团队将通过 Remix Jam 分享进展，并邀请社区参与反馈和讨论。

---

### [合并 Remix 和 React Router | Remix](https://remix.run/blog/merging-remix-and-react-router)

**原文标题**: [Merging Remix and React Router | Remix](https://remix.run/blog/merging-remix-and-react-router)

React Router 和 Remix 将合并，React Router v7 将包含 Remix 的核心功能，Remix 用户只需更改导入即可升级。  

- 🎉 **React Router v7 发布**：推荐新项目使用 v7，现有 Remix 应用可升级。  
- 🌉 **项目合并**：Remix 和 React Router 功能趋同，Remix 将成为 React Router 的上层框架。  
- 🚀 **功能整合**：v7 将包含 Remix 的自动代码分割、简化数据加载、表单操作、SSR 等特性。  
- ⚡ **Vite 支持**：Remix 已转向 Vite，提供更快的开发体验和优化构建。  
- 🔄 **平滑升级**：未来版本升级只需更改导入，提供 codemod 和指南简化流程。  
- 📅 **未来计划**：Remix 品牌保留，团队将专注于 React Router v7 和更强大的服务端方案。  
- 💬 **社区支持**：用户可通过 Discord、Twitter 和订阅更新获取最新动态。

---

### [React Router 官方文档](https://reactrouter.com/)

**原文标题**: [React Router Official Documentation](https://reactrouter.com/)

一个用户至上、标准导向、多策略的路由器，可部署在任何地方。提供文档、GitHub 和 Discord 支持。

- 📚 **文档支持** - 提供详细的文档帮助用户了解和使用 React Router。  
- 🐙 **GitHub 资源** - 开源代码和社区支持可在 GitHub 上获取。  
- 💬 **Discord 交流** - 通过 Discord 与其他开发者交流并获得帮助。  
- 🔄 **无破坏性升级** - 从 v6 升级到 v7 无需更改现有代码，保持原有使用方式。  
- 🌉 **React 18 到 19 的桥梁** - 新的打包、服务器渲染、预渲染和流式功能，支持逐步升级到 React 19。  
- 🛡️ **类型安全** - 新增类型生成功能，为路由参数、加载器数据、操作等提供一流的类型支持。  
- 🆕 **新手入门** - 提供学习资源，帮助新用户快速掌握 React Router。  
- ⬆️ **v6 用户升级指南** - 简单几步即可从 v6 升级到 v7。  
- 🛠️ **框架功能适配** - 指导现有 React Router 应用如何适配新框架功能。  
- ❓ **获取帮助** - 通过 GitHub 讨论区寻求帮助和支持。  
- ©️ **版权信息** - 2025 年由 Shopify, Inc.提供支持。

---

### [Preact](https://preactjs.com/)

**原文标题**: [Preact](https://preactjs.com/)

Preact 是一个轻量级的 React 替代方案，提供相同的现代 API，体积仅 3kB，性能卓越且易于集成。

- ⚡ **轻量高效**：Preact 是体积最小的虚拟 DOM 库之一，下载和执行速度快，性能优越。  
- 🏗️ **贴近 DOM**：直接在浏览器中运行，无需转译，与其他库兼容性好。  
- 📦 **体积小巧**：代码体积小，应用的主要部分由开发者代码构成，减少框架负担。  
- 🚀 **高性能**：采用简单可预测的 diff 算法，自动批量更新，优化极致性能。  
- 🔄 **便携嵌入**：可嵌入到现有应用中，构建部分功能或独立组件。  
- 🛠️ **开箱即用**：支持标准 HTML 属性（如`class`和`for`），提升开发效率。  
- 🌐 **生态兼容**：通过`preact/compat`兼容 React 生态，可复用大量 React 组件。  
- 📝 **示例丰富**：提供待办列表、GitHub 星标等实例，展示其灵活性和实用性。  
- 🌍 **多语言支持**：提供多种语言文档，包括中文、英语、日语等。  
- 💖 **社区驱动**：由活跃社区开发和维护，得到众多贡献者支持。

---

### [React Router 开放治理 | Remix](https://remix.run/blog/rr-governance)

**原文标题**: [React Router Open Governance | Remix](https://remix.run/blog/rr-governance)

React Router 宣布采用开放治理模式，旨在让社区更广泛地参与项目决策，同时简化 API 并保持核心功能。以下是关键内容：

- 🚀 **开放治理**：React Router 从创始人主导转向开放治理模式，由指导委员会（目前为 Remix 团队）监督，鼓励社区贡献和反馈。  
- 🔄 **简化 API**：计划减少冗余 API，整合功能，并优先支持 React 原生功能（如 RSC），目标是让 React Router 更轻量。  
- 📅 **稳定发布节奏**：计划每年发布一个主版本，通过未来标志（future flags）提前预告变更，确保平滑迁移。  
- 🛠️ **近期重点**：稳定 React Router v7 的试验性功能（如中间件、路由模块拆分），并新增类型安全钩子（如`useRouterState`）和更灵活的路由匹配器。  
- 📜 **RFC 流程**：采用类似 TC39 的分阶段提案流程（从讨论到稳定），确保新功能经过充分验证。  
- 🤝 **社区参与**：开放 RFC 提案和测试，未来可能扩大指导委员会成员范围。  
- 😊 **兼容性承诺**：重大变更会提前警告，且仅当 React 提供同等替代方案时才会废弃 API。  

（注：文末幽默提到“如需情绪支持请咨询心理医生”，实为调侃开源版本升级的压力。）

---

### [JavaScript 框架渲染 DOM 的 3 种方式 - YouTube](https://www.youtube.com/watch?v=0C-y59betmY)

**原文标题**: [The 3 Ways JavaScript Frameworks Render the DOM - YouTube](https://www.youtube.com/watch?v=0C-y59betmY)

该内容为 YouTube 平台的相关链接和版权信息，涉及多个功能和服务条款。

- 📢 关于我们  
- 🗞️ 新闻动态  
- ©️ 版权声明  
- 📩 联系我们  
- � 创作者信息  
- 💼 广告合作  
- 💻 开发者资源  
- 📜 使用条款  
- 🔒 隐私政策  
- ⚖️ 政策与安全  
- 🔧 YouTube 运作机制  
- 🧪 测试新功能  
- © 2025 Google LLC

---

### [将用户数据从 Clerk 同步至 Supabase](https://clerk.com/blog/sync-clerk-user-data-to-supabase?utm_source=cooper-press&utm_medium=newsletter&utm_campaign=clerk-supabase-sync&utm_content=06-11-25&dub_id=YWJsHLa3Xeo9Vssn)

**原文标题**: [Synchronize user data from Clerk to Supabase](https://clerk.com/blog/sync-clerk-user-data-to-supabase?utm_source=cooper-press&utm_medium=newsletter&utm_campaign=clerk-supabase-sync&utm_content=06-11-25&dub_id=YWJsHLa3Xeo9Vssn)

本文介绍了如何通过 Clerk 的 Webhooks 和 Supabase Functions 将用户数据同步到 Supabase 数据库，并提供了具体的实现步骤和代码示例。

- 📌 使用 Clerk 的 Backend API 可以实时获取最新的用户数据，但需要注意 API 的速率限制。
- 🔄 通过 Webhooks 和 Supabase Functions 可以异步同步用户数据到 Supabase 数据库，适用于需要本地访问用户数据的场景。
- 🛠️ 文章提供了一个实际项目 Quillmate 的示例，展示了如何实现用户数据的同步。
- 📝 详细介绍了如何创建和配置 Supabase Edge Function 以及如何设置 Clerk Webhook。
- ✅ 结论指出，结合 Clerk 的 Webhooks 和 Supabase Edge Functions 可以有效地同步用户数据，适用于各种应用场景。

---

### [2025 年创建 React + Flask 项目 - miguelgrinberg.com](https://blog.miguelgrinberg.com/post/create-a-react-flask-project-in-2025)

**原文标题**: [
  
    Create a React + Flask Project in 2025 - miguelgrinberg.com
  
](https://blog.miguelgrinberg.com/post/create-a-react-flask-project-in-2025)

概述：本文介绍了如何在 2025 年创建一个结合 React 和 Flask 的项目，重点介绍了使用 Vite 替代已不再维护的 create-react-app 来搭建 React 应用，并详细说明了前后端的配置和集成步骤。

- 🚀 作者更新了 2020 年的 React + Flask 项目构建方法，改用 Vite 替代 create-react-app。  
- ⚙️ 项目要求：Python 3.12 和 Node.js 22（或更新的版本）。  
- 📂 使用 Vite 创建 React 项目：运行`npm create vite@latest react-with-flask -- --template react`。  
- 🔧 配置 Vite 代理：修改`vite.config.js`，将 API 请求转发到 Flask 服务器的 5000 端口。  
- 🐍 创建 Flask 后端：在项目目录下创建`api`子目录，设置虚拟环境并安装 Flask 和 python-dotenv。  
- 🔄 前后端集成：在 React 中使用`fetch`调用 Flask API，并通过`useEffect`和`useState`管理状态。  
- 🚦 运行项目：分别启动 Vite 开发服务器（`npm run dev`）和 Flask 服务器（`npm run api`）。  
- 📅 示例功能：前端显示从 Flask 获取的当前时间。  
- 📚 相关资源：作者提供了部署和 Docker 化的后续文章链接。

---

### [如何创建自己的简易 useState 钩子](https://www.deepintodev.com/blog/how-to-create-your-own-simple-use-state-hook)

**原文标题**: [How to Create Your Own Simple useState Hook](https://www.deepintodev.com/blog/how-to-create-your-own-simple-use-state-hook)

本文介绍了如何从零开始实现一个简化版的 React `useState`钩子，并解释了 React 钩子规则背后的原理。

- 🛠️ 创建一个简化版`useState`函数，接收初始值并返回状态和更新函数。  
- 🔄 使用闭包和全局变量`stateValue`来保持状态持久化，避免每次渲染重置。  
- 🖥️ 通过自定义`render`函数实现状态更新后重新渲染组件。  
- 📌 引入`stateValues`数组和`callIndex`全局变量，支持多个`useState`调用各自独立的状态。  
- 🔄 每次渲染前重置`callIndex`，确保状态按调用顺序正确匹配。  
- 🔒 利用闭包保存`currentIndex`，解决异步更新时索引错乱的问题。  
- ⚠️ 解释了 React 钩子规则（如顶层调用、仅在组件内使用）的必要性：依赖稳定的调用顺序和组件实例关联。  
- 💡 最终代码实现了多状态管理，并验证了 React 底层状态跟踪的核心机制。

---

### [React 2025 设计模式与最佳实践](https://www.telerik.com/blogs/react-design-patterns-best-practices)

**原文标题**: [
	React Design Patterns and Best Practices for 2025
](https://www.telerik.com/blogs/react-design-patterns-best-practices)

本文探讨了 2025 年 React 的设计模式、最佳实践和生态系统更新，包括现代组件模式、状态管理方法、TypeScript 集成以及 React 19 的新特性。

- 🚀 React 19 的稳定发布带来了新特性，如 use API 和 useOptimistic 钩子，优化了开发流程和应用性能。
- ⚛️ 函数组件成为 React 开发的标准，取代了类组件，强调简洁性和可组合性。
- 🔄 自定义钩子用于逻辑复用，将状态逻辑提取为可重用函数，提升代码复用和关注点分离。
- 🌐 Context API 用于应用范围的状态管理，React 19 引入 use 函数简化上下文值的访问。
- 🛠 TypeScript 成为 React 开发的重要组成部分，提供类型安全、改进的开发者体验和自文档化代码。
- 🔄 React Server Components 代表了一种新的范式，允许组件在服务器端运行，直接访问数据源，减少客户端 API 调用。
- 📊 现代 React 框架如 Next.js、Remix 和 Vite 提升了开发者体验和应用性能。
- 🎨 Tailwind CSS 成为 React 应用样式的流行选择，提供低级别的实用类，直接在 JSX 标记中组合。
- 📚 KendoReact 提供了一套全面的 UI 组件，适用于企业级应用，包括复杂的组件和高级功能。
- 🔗 文章还提供了相关资源的链接，帮助开发者深入了解和掌握这些技术和工具。

---

### [从 Next.js 迁移 | TanStack Start React 文档](https://tanstack.com/start/latest/docs/framework/react/migrate-from-next-js)

**原文标题**: [Migrate from Next.js | TanStack Start React Docs](https://tanstack.com/start/latest/docs/framework/react/migrate-from-next-js)

本文提供了从 Next.js App Router 迁移到 TanStack Start 的详细指南，包括基础步骤和高级功能。

- 🛠️ **迁移基础步骤**  
  1. 移除 Next.js 及相关配置文件  
  2. 安装 TanStack Start、Vite 和 TanStack Router 等依赖  
  3. 更新项目配置文件（如`package.json`和`vite.config.ts`）  
  4. 将`layout.tsx`调整为`__root.tsx`作为根布局  
  5. 将`page.tsx`调整为`index.tsx`作为首页  
  6. 创建路由文件`router.tsx`  
  7. 验证迁移结果  

- 🚀 **高级功能与概念**  
  - **路由调整**：动态路由（如`$slug.tsx`）和全捕获路由（如`$.tsx`）  
  - **链接组件**：使用`@tanstack/react-router`的`Link`替换`next/link`  
  - **服务器功能**：通过`createServerFn`定义服务端逻辑  
  - **字体处理**：使用 Tailwind CSS 和 Fontsource 替代`next/font`  
  - **数据获取**：通过`loader`和`useLoaderData`实现  

- 📌 **注意事项**  
  - 当前指南基于 TanStack Start 的 alpha 版本，后续会更新  
  - 迁移过程中需注意文件路径和配置的准确性  

- 🔗 **扩展资源**  
  - 提供完整的[迁移示例仓库](https://github.com/tanstack/start)参考  
  - 推荐阅读官方文档中的[路由概念](https://tanstack.com/start/latest/docs/routing)和[服务器功能](https://tanstack.com/start/latest/docs/server)部分

---

### [React 开发者指南：SolidJS](https://marmelab.com/blog/2025/05/28/solidjs-for-react-developper.html)

**原文标题**: [SolidJS for React Developers](https://marmelab.com/blog/2025/05/28/solidjs-for-react-developper.html)

概述：本文由一位 React 开发者分享尝试 SolidJS 的经历，重点解析了 SolidJS 与 React 的核心差异、内部工作原理及使用注意事项，帮助开发者避免常见陷阱并充分利用其细粒度响应式优势。

- 🏠 **框架简介**：SolidJS 是一个响应式 UI 库，表面类似 React（组件化、JSX、类 Hook 函数），但底层采用无虚拟 DOM 的细粒度响应式机制。  
- 🔄 **核心差异**：Solid 组件仅初始化执行一次，依赖信号（Signal）和观察者模式精准更新 DOM，而非重新渲染整个组件。  
- ⚠️ **常见陷阱**：  
  - 避免在组件内直接使用条件语句（如`if`/`map`），需用`<Show>`、`<For>`等控制流组件。  
  - 不可解构 Props 或 Store，否则会破坏响应性。  
  - `createEffect`内避免异步代码，需嵌套子 Effect 处理异步逻辑。  
- 🛠️ **内部原理**：  
  - 信号（Signal）本质是观察者模式，getter 自动追踪依赖，setter 触发更新。  
  - Props 和 Store 通过 Getter/Proxy 实现惰性求值与动态响应。  
- 📦 **生态工具**：支持 TanStack、Testing Library 等，提供 ESLint 插件检测响应性破坏代码。  
- 💡 **总结建议**：遵循 SolidJS 规则（如控制流组件、非解构访问），可显著提升性能。

---

### [Remix V3 的致命缺陷 - YouTube](https://www.youtube.com/watch?v=5SPqO6NR_Bg)

**原文标题**: [Remix V3's Fatal Flaw - YouTube](https://www.youtube.com/watch?v=5SPqO6NR_Bg)

这是一个关于 YouTube 平台相关信息和服务的概览页面，列出了各项功能与政策的链接。

- 📢 关于 YouTube 平台的基本信息  
- 🗞️ 媒体与新闻相关资源  
- ©️ 版权信息与政策  
- 📩 联系 YouTube 的方式  
- 🎨 内容创作者相关资源  
- 💼 广告合作与推广服务  
- 💻 开发者工具与资源  
- 📜 使用条款与条件  
- 🔒 隐私政策与数据保护  
- ⚖️ 平台政策与安全指南  
- 🔧 YouTube 功能运作机制  
- 🧪 新功能测试与体验  
- ®️ 谷歌公司版权声明（2025 年）

---

### [Storybook 9](https://storybook.js.org/blog/storybook-9/)

**原文标题**: [Storybook 9](https://storybook.js.org/blog/storybook-9/)

Storybook 9 是一个专注于组件测试的高效工具，通过与最新测试工具（如 Vitest 和 Playwright）的集成，提供了全面的 UI 测试解决方案。  

- 🚀 **Storybook 9 的核心优势**：提供全面的 UI 状态展示和测试支持，是自动化测试的理想基础。  
- ⚡ **测试工具集成**：Vitest 提供最快的测试运行器，Playwright 确保浏览器高保真度。  
- ▶️ **交互测试**：模拟用户行为验证功能。  
- ♿ **无障碍测试**：检测并修复 WCAG 违规问题。  
- 👁️ **视觉测试**：检查像素级的外观问题。  
- 🛡️ **测试覆盖率报告**：一目了然地了解代码测试情况。  
- 🚥 **测试小部件**：一键运行全面的测试套件。  
- 🪶 **体积更小**：安装包比 Storybook 8 小 48%，依赖更扁平化。  
- ✍️ **故事生成**：自动生成和编辑故事，支持测试代码生成。  
- 🏷️ **标签管理**：通过标签组织和过滤故事。  
- 🌐 **全局故事设置**：支持按故事或组件设置上下文变量（如主题、视口等）。  
- 🏗️ **框架升级**：对 Svelte、Next.js、React Native 等框架进行了重大改进。  
- 📱 **React Native 支持**：同时支持 React Native 和 React Native Web，提供完整的开发体验。  
- 📅 **未来计划**：进一步优化安装体积、模块模拟和类型安全性。  
- 📢 **试用方式**：新项目可通过`npm create storybook@latest`创建，现有项目可使用迁移向导升级。  

Storybook 9 的目标是提供更高效、更全面的组件测试体验，帮助开发者轻松管理复杂的 UI 状态和测试需求。

---

### [Partycles - 适用于 React 的美丽粒子动画](https://jonathanleane.github.io/partycles/)

**原文标题**: [Partycles - Beautiful Particle Animations for React](https://jonathanleane.github.io/partycles/)

该内容提示需要启用 JavaScript 才能运行应用程序。

- 🛠️ 需要启用 JavaScript 以运行此应用

---

### [React 最终表单](https://final-form.org/react)

**原文标题**: [React Final Form](https://final-form.org/react)

React Final Form 是一个高性能、基于订阅的 React 表单状态管理库，具有模块化设计、零依赖、卓越性能及 Hooks 兼容性等特点。

- 🧩 **模块化设计**：可根据需求自由组合表单库组件，避免冗余代码。  
- 📦 **零依赖**：仅依赖 React 和 Final Form，极简打包体积（总计约 9.5KB gzipped）。  
- ⚡ **高性能优化**：精准控制表单状态更新的通知范围，避免大规模表单的性能损耗。  
- 🎣 **Hooks 兼容**：提供与内部一致的 Hooks API，支持灵活的功能组合。  
- 🌍 **社区支持**：提供 Discord、Stack Overflow 和 GitHub 等渠道的开发者支持。  
- ⭐ **用户案例**：被多家知名公司采用（支持查看更多用户案例）。  
- 📚 **快速入门**：提供详细的文档和 API 参考，帮助开发者快速上手。

---

### [🏁 终极形态转向 TypeScript](https://erikras.com/blog/final-form-to-typescript)

**原文标题**: [🏁 Final Form goes to TypeScript](https://erikras.com/blog/final-form-to-typescript)

🏁 Final Form 已全面迁移至 TypeScript，所有相关模块已完成现代化改造，并发布了新版本。  

- 🚀 2017 年开发时选择 Flow，但后来 TypeScript 胜出，现决定迁移至 TypeScript  
- 🔄 2020 年后作者因工作变动减少维护，但认为 Final Form 功能已基本完善  
- 📜 表单状态管理的核心问题（值、验证、提交等）长期不变，Final Form 仍适用  
- 🤖 通过 LLM（大型语言模型）协助将代码从 Flow 转换为 TypeScript，测试覆盖率确保无 bug  
- 🆕 所有相关库版本升级（如 final-form v5.0.0、react-final-form v7.0.0 等）  
- 🏛️ 作者希望未来能更积极维护，但仍未承诺长期投入  
- 🦗 多次呼吁志愿者接手维护，但未获响应  
- ❤️ 感谢社区支持，欢迎在 Twitter 讨论

---

### [GitHub - final-form/react-final-form: 🏁 基于订阅的高性能 React 表单状态管理](https://github.com/final-form/react-final-form)

**原文标题**: [GitHub - final-form/react-final-form: 🏁 High performance subscription-based form state management for React](https://github.com/final-form/react-final-form)

react-final-form 是一个基于订阅机制的高性能 React 表单状态管理库，它是 Final Form 的 React 封装版本，专注于优化渲染性能，仅更新需要变化的组件。

- 🏁 **高性能表单管理** - 采用订阅机制，仅更新必要的组件，优化性能。  
- 📦 **轻量无依赖** - 不影响打包体积，仅有 React 和 Final Form 作为 peer 依赖。  
- 💡 **灵活的订阅机制** - 可选择性地订阅需要的表单状态，减少不必要的渲染。  
- 🚀 **低体积开销** - 压缩后仅约 3.0KB，适合对性能敏感的应用。  
- 🔍 **基于观察者模式** - 利用 Final Form 的订阅系统，实现高效状态管理。  
- 📜 **丰富的文档与示例** - 提供详细文档和多种示例，便于快速上手。  
- 🌍 **社区支持** - 鼓励用户反馈，持续优化库的功能和体验。  
- ⚖️ **MIT 许可证** - 开源免费，可自由使用和修改。  
- 🔧 **多语言支持** - 代码库主要使用 JavaScript (78.2%) 和 TypeScript (21.8%)。  
- ✨ **企业赞助** - 由 Sencha 提供支持，适合企业级应用开发。

---

### [GitHub - Jonghakseo/chrome-extension-boilerplate-react-vite: React + Vite + Typescript 的 Chrome 扩展开发模板](https://github.com/Jonghakseo/chrome-extension-boilerplate-react-vite)

**原文标题**: [GitHub - Jonghakseo/chrome-extension-boilerplate-react-vite: Chrome Extension Boilerplate with React + Vite + Typescript](https://github.com/Jonghakseo/chrome-extension-boilerplate-react-vite)

这是一个基于 React、Vite 和 TypeScript 的 Chrome/Firefox 扩展开发模板项目，提供了快速构建浏览器扩展的脚手架工具。

- 🚀 **项目简介**: 使用 React + Vite + TypeScript 技术栈的浏览器扩展开发模板，支持 Chrome 和 Firefox
- ⚡ **核心特性**: 
  - 支持热模块重载 (HMR)
  - 集成 TailwindCSS、Prettier、ESLint 等现代前端工具
  - 使用 Turborepo 进行多包管理
  - 支持 Chrome 扩展 Manifest V3
- 📁 **项目结构**:
  - chrome-extension 目录包含扩展核心文件
  - pages 目录包含各种扩展页面 (弹窗、选项页等)
  - packages 目录包含共享工具包 (i18n、storage 等)
- 🔧 **安装使用**:
  - 需要 Node.js 环境 (版本参考.nvmrc)
  - 推荐使用 pnpm 作为包管理器
  - 提供开发和生产构建命令
- 🌐 **多浏览器支持**:
  - Chrome: 开发模式 pnpm dev，生产构建 pnpm build
  - Firefox: 开发模式 pnpm dev:firefox，生产构建 pnpm build:firefox
- 🛠 **开发工具**:
  - 提供自定义 i18n 包
  - 包含端到端测试 (WebdriverIO)
  - 支持模块管理 (启用/禁用特定模块)
- ❗ **注意事项**:
  - Windows 用户建议启用 WSL
  - 生产环境需调整 manifest 权限设置
  - 提供常见问题解决方案 (HMR 冻结、导入解析问题等)
- 🤝 **社区支持**: 提供 Discord 社区交流渠道
- 📜 **开源协议**: MIT 许可证

---

### [GitHub - vadimdemedes/ink：🌈 用于交互式命令行应用的 React](https://github.com/vadimdemedes/ink)

**原文标题**: [GitHub - vadimdemedes/ink: 🌈 React for interactive command-line apps](https://github.com/vadimdemedes/ink)

Ink 是一个基于 React 的命令行应用开发工具，允许开发者使用 React 组件构建交互式命令行界面。它支持 Flexbox 布局，并提供了丰富的组件和钩子来管理用户输入、输出和焦点控制。

- 🌈 **React 组件化开发**：使用熟悉的 React 语法构建命令行界面。
- 📦 **Flexbox 布局**：通过 Yoga 引擎支持 CSS 类似的布局属性。
- 🎨 **样式支持**：支持文本颜色、背景色、粗体、斜体等多种样式。
- 📝 **组件库**：提供 `<Text>`、`<Box>`、`<Newline>` 等基础组件。
- 🎮 **用户输入处理**：通过 `useInput` 钩子监听键盘输入。
- 🔍 **焦点管理**：支持组件间的焦点切换。
- 📊 **静态输出**：使用 `<Static>` 组件渲染不会变化的输出。
- 🛠 **API 丰富**：提供 `render`、`rerender`、`unmount` 等方法管理应用生命周期。
- 🧪 **测试友好**：兼容 `ink-testing-library` 进行组件测试。
- 🔧 **开发工具**：支持 React Devtools 进行调试。
- 📂 **示例丰富**：提供计数器、表单、表格等多种示例。
- 🌍 **社区支持**：被多个知名项目如 Gatsby、Prisma 等使用。

---

### [GitHub - software-mansion/react-native-reanimated: 重新实现的 React Native 动画库](https://github.com/software-mansion/react-native-reanimated)

**原文标题**: [GitHub - software-mansion/react-native-reanimated: React Native's Animated library reimplemented](https://github.com/software-mansion/react-native-reanimated)

React Native Reanimated 是一个重新实现的 React Native Animated 库，专注于提供流畅的动画和优秀的开发者体验。

- 🚀 **项目简介**: React Native Reanimated 是 React Native 动画库的重新实现，旨在提供更流畅的动画效果和更好的开发体验。
- 📄 **文档**: 详细文档可在 [docs.swmansion.com/react-native-reanimated/](https://docs.swmansion.com/react-native-reanimated/) 查看。
- ⚙️ **兼容性**: 仅支持 React Native 新架构和最新的三个 React Native 版本。
- 📂 **示例**: 示例应用代码位于 `apps/common-app` 目录，可通过示例 README 查看安装说明。
- 📜 **许可证**: 采用 MIT 许可证。
- 💡 **支持**: 由 Shopify、Expo.io 和 Software Mansion 支持。
- 💬 **社区**: 可加入 Software Mansion Community Discord 进行交流。
- 👥 **贡献者**: 项目有 359 位贡献者。
- 🌟 **受欢迎度**: 9.7k 星标，1.4k 复刻。

---

### [GitHub - instea/react-native-popup-menu: React Native 弹出菜单组件](https://github.com/instea/react-native-popup-menu)

**原文标题**: [GitHub - instea/react-native-popup-menu: Popup menu component for React Native](https://github.com/instea/react-native-popup-menu)

这是一个关于 React Native 弹出菜单组件的 GitHub 仓库介绍。

- 🚀 **项目名称**: react-native-popup-menu  
- ⭐ **Star 数**: 1.5k  
- 🍴 **Fork 数**: 252  
- 📜 **许可证**: ISC license  

- 🌟 **功能特点**:  
  - 简单易用的弹出/上下文菜单  
  - 支持多种模式：动画、非动画、从底部滑入或弹出  
  - 默认包含打开和关闭动画  
  - 可选的返回按钮处理  
  - 易于样式定制  
  - 支持 RTL 布局  

- 🌍 **社区支持**:  
  - 支持 UWP、react-native-web 和 react-native-desktop  
  - 提供 TypeScript 定义  

- 📦 **安装方法**:  
  ```bash
  npm install react-native-popup-menu --save
  ```

- 📖 **基本用法**:  
  - 在应用入口点使用`MenuProvider`包裹应用  
  - 在需要的地方使用`Menu`、`MenuOptions`、`MenuOption`和`MenuTrigger`组件  

- 🔧 **文档**:  
  - 提供详细 API 文档和示例  

- 🤝 **贡献**:  
  - 欢迎提交问题和拉取请求  

- 🔄 **兼容性**:  
  - 支持 React Native 0.55 及以上版本  

- 📌 **相关主题**:  
  - android, ios, react-native, animation, popup-menu

---

### [GitHub - heyman333/react-animated-numbers: 👾 React.js 数字变化动画库](https://github.com/heyman333/react-animated-numbers)

**原文标题**: [GitHub - heyman333/react-animated-numbers: 👾 Library showing animation of number changes in react.js](https://github.com/heyman333/react-animated-numbers)

这是一个名为 `react-animated-numbers` 的 React 动画数字库，用于展示数字变化的动画效果。

- 👾 **项目简介**: 一个用于在 React.js 中展示数字变化动画的库。
- ⭐ **项目数据**: 291 个星标，32 个 Fork。
- 📜 **许可证**: 采用 MIT 许可证。
- 🛠️ **主要功能**: 
  - 支持数字动画效果。
  - 可自定义字体样式。
  - 支持千位分隔符。
  - 支持本地化格式。
  - 使用 `framer-motion` 过渡效果。
- ⚙️ **使用示例**: 提供了在 Next.js 和普通 React 项目中的使用示例。
- 📦 **兼容性**: 支持 Next.js（包括 v13.x.x 及以上版本）。
- 📝 **待办事项**: 包括添加测试代码和优化 DOM 可见时动画启动功能。
- 🌍 **语言**: 项目使用 TypeScript 编写。

---

### [GitHub - Skipperlla/rn-swiper-list: ⚡ 为 React Native 打造的闪电般快速且可自定义的类 Tinder 滑动组件](https://github.com/Skipperlla/rn-swiper-list)

**原文标题**: [GitHub - Skipperlla/rn-swiper-list: ⚡ Lightning fast and customizable tinder-like swiper for React Native](https://github.com/Skipperlla/rn-swiper-list)

这是一个名为 `rn-swiper-list` 的 React Native 组件库，提供了类似 Tinder 的快速滑动卡片功能，支持高度自定义和丰富的动画效果。

- ⚡ **快速且可定制**：闪电般快速的 Tinder 式滑动卡片组件，适用于 React Native。
- 📦 **依赖安装**：需要安装 `react-native-reanimated` 和 `react-native-gesture-handler` 依赖包。
- 🎨 **动画效果**：支持旋转动画、缩放动画、覆盖标签等多种动画效果。
- 🔄 **滑动回调**：提供多种滑动事件回调，如左滑、右滑、上滑、下滑等。
- 📱 **卡片属性**：支持自定义卡片样式、预渲染数量、循环滑动等功能。
- 🛠️ **滑动方法**：支持手动触发滑动（如 `swipeLeft`、`swipeRight`、`swipeBack` 等）。
- ⚙️ **弹簧配置**：可自定义滑动动画的弹簧参数（如阻尼、刚度、质量等）。
- 📂 **示例代码**：提供了详细的示例代码和使用方法。
- 📜 **开源协议**：采用 MIT 开源协议，允许自由使用和修改。
- 🤝 **贡献指南**：欢迎开发者通过提交 PR 或 Issue 参与项目贡献。

---

### [发布 10.9.6 · primefaces/primereact · GitHub](https://github.com/primefaces/primereact/releases/tag/10.9.6)

**原文标题**: [Release 10.9.6 · primefaces/primereact · GitHub](https://github.com/primefaces/primereact/releases/tag/10.9.6)

PrimeReact 版本 10.9.6 的更新内容，包含多个组件的修复和改进，以及新功能的添加。

- 🐛 **修复文档类型错误**：修正了 PickList 文档中的类型错误 (#7938)  
- 📊 **数据表改进**：修复了 Datatable BodyRow 文档 (#5353) 和导出功能 (#7953)  
- 🖼️ **Galleria 修复**：确保首次渲染时过渡效果正确运行 (#7944)  
- 📤 **文件上传修复**：解决了清除上传文件时显示错误文本的问题 (#7949)  
- 🌍 **本地化改进**：优化了导出函数的本地化选项类型 (#7967)  
- 🗂️ **下拉菜单修复**：解决了 onClick 事件被调用两次的问题 (#7941)  
- 📅 **日历功能修复**：修复了手动输入日期格式问题 (#7971) 并恢复了秒和毫秒支持 (#7972)  
- 🌳 **TreeSelect 新功能**：添加了节点点击和双击回调 (#7975)  
- 🔢 **InputNumber 改进**：根据本地化设置使用小数分隔符 (#7996)  
- 🚀 **新贡献者加入**：多位开发者首次贡献 (#7939, #7967, #7986 等)  
- 🔄 **其他修复**：包括 DataTable、MultiStateCheckbox、FileUpload 等组件的多项改进和问题修复  

完整更新日志和贡献者列表可查看 [10.9.5...10.9.6](链接)。

---

### [Astro 5.9 | Astro](https://astro.build/blog/astro-590/)

**原文标题**: [Astro 5.9 | Astro](https://astro.build/blog/astro-590/)

Astro 5.9 版本带来了多项实验性功能和安全增强，包括内容安全策略（CSP）支持、Markdown 渲染优化以及适配器日志控制等。

- 🔒 **实验性内容安全策略（CSP）支持**：新增 CSP 功能，通过生成 `<meta>` 元素和哈希值，有效防御跨站脚本（XSS）攻击，支持所有 Astro 渲染模式。  
- 📝 **在内容加载器中渲染 Markdown**：新增 `renderMarkdown` 辅助函数，允许在自定义加载器中直接渲染 Markdown 内容，并保持与项目配置一致。  
- 🖼️ **禁用实验性响应式图片的默认样式**：新增 `image.experimentalDefaultStyles` 配置选项，方便用户（尤其是 Tailwind 4 用户）覆盖默认样式。  
- 📢 **适配器支持抑制日志**：适配器现在可以通过 `suppress` 选项控制功能支持相关的日志输出，避免冗余或冲突信息。  
- ⚙️ **升级指南**：推荐使用 `@astrojs/upgrade` CLI 工具或手动运行包管理器的升级命令（如 `npm install astro@latest`）更新项目。  
- 🌟 **社区贡献**：感谢核心团队及众多社区开发者的代码和文档贡献，共同推动 Astro 5.9 的发布。  

（注：其他版本如 5.8 和 5.7 的更新内容未在摘要中展开。）

---

### [一丝不苟](https://www.meticulous.ai?utm_source=react_status&utm_campaign=june11th2025)

**原文标题**: [Meticulous](https://www.meticulous.ai?utm_source=react_status&utm_campaign=june11th2025)

Meticulous AI 是一款无需编写和维护测试的自动化测试工具，通过记录用户交互生成覆盖所有边缘情况的测试套件，帮助开发者快速发现和预防回归问题。

- 🚀 **无需编写测试** - 通过记录开发、预发布和生产环境中的用户交互，自动生成全面的测试套件。  
- 🤖 **AI 驱动** - AI 引擎持续更新测试套件，覆盖所有代码分支和用户流程，确保测试始终与应用程序同步。  
- ⚡ **快速集成** - 只需添加脚本标签到开发环境，即可开始记录会话并生成测试。  
- 🛡️ **零误报** - 通过模拟后端响应，避免因数据变化导致的误报，无需额外配置测试账户或模拟数据。  
- 🔧 **无缝协作** - 在提交代码前查看 PR 对用户流程的影响，确保代码合并无忧。  
- 🏗️ **高性能测试** - 基于 Chromium 的确定性调度引擎，消除测试波动，并行执行数千次测试，结果在 120 秒内返回。  
- 💡 **灵活使用** - 可单独使用或与现有测试套件结合，适用于 NextJS、React、Vue、Angular 等多种框架。  
- 📈 **客户认可** - 被 Dropbox、WithPower、Lattice 等 100 多家组织信任，显著提升开发效率和代码质量。  
- 📚 **快速上手** - 提供详细文档和多种框架的集成示例，几分钟内即可开始使用。

---

### [比特云。AI 软件构建平台。](https://bit.cloud/?utm_source=ReactStatus&utm_id=130&utm_medium=referral%20)

**原文标题**: [Bit Cloud. AI software composition platform.](https://bit.cloud/?utm_source=ReactStatus&utm_id=130&utm_medium=referral%20)

好的，请提供需要总结的文本内容，我会按照您要求的模板生成概述和带表情符号的要点列表。  

示例模板：  

概述内容  

- 🌟 要点 1  
- 📌 要点 2  
- 🔍 要点 3  

请提供具体文本，我会为您生成符合要求的总结。

---

### [比特云。AI 软件构建平台](https://bit.cloud/?utm_source=ReactStatus&utm_id=130&utm_medium=referral)

**原文标题**: [Bit Cloud. AI software composition platform.](https://bit.cloud/?utm_source=ReactStatus&utm_id=130&utm_medium=referral)

好的，请提供需要总结的文本内容，我会按照您要求的格式生成概述和带表情符号的要点列表。  

示例格式：  

这里是文章的概述总结  

- 🌟 第一个关键点  
- 📊 第二个关键点  
- 🔍 第三个关键点  

请提供具体文本，我会为您生成相应的总结！

---

### [React 美国峰会 —— 美国最大的 React 技术大会](https://reactsummit.us/?utm_source=Newsletter&utm_medium=ReactStatus%20)

**原文标题**: [React Summit US – The Biggest React Conference in the US](https://reactsummit.us/?utm_source=Newsletter&utm_medium=ReactStatus%20)

React Summit 是美国最大的 React 技术会议，提供线上线下混合参与形式，汇聚全球开发者与行业专家，分享最新技术趋势和实践经验。

- 🎤 **演讲嘉宾**：包括来自 Google Chrome、Netflix、Meta 等公司的行业领袖，分享 React、Next.js、TypeScript 等前沿技术。  
- 🌍 **活动形式**：混合模式（线上 + 线下），首日线下活动在纽约举行，次日及免费工作坊全球直播。  
- 🗓️ **活动日期**：2025 年 6 月 13 日 & 17 日（阿姆斯特丹），2025 年 11 月 18 日 & 21 日（纽约）。  
- 🎟️ **门票选项**：提供线下参与、远程参与及 Multipass 通票等多种选择，包含讲座、工作坊和社交活动。  
- 🏙️ **特色体验**：在西方最大的天文馆举办演讲，乘坐渡轮欣赏曼哈顿景色，参与美国最大的 React 派对。  
- 🛠️ **技术焦点**：涵盖 React 19、React Compiler、AI 工程、React Server Components 等热门话题。  
- 🎓 **免费工作坊**：提供 TypeScript、React 测试、高级 React 等实践培训。  
- 📍 **活动地点**：纽约自由科学中心（Liberty Science Center），拥有西半球最大的天文馆。  
- 🤝 **赞助与合作**：得到 Facebook、Vercel 等公司的支持，欢迎更多合作伙伴加入。  
- 📢 **参与方式**：可通过分享个人徽章获取免费远程门票，或订阅通讯获取独家优惠。

---

### [卷下](https://rolldown.rs/)

**原文标题**: [Rolldown](https://rolldown.rs/)

Rolldown 能够高效处理数以万计的模块，性能卓越且稳定。

- 🚀 高效处理：Rolldown 轻松应对数万模块，性能无压力  
- 💪 稳定可靠：即使在高负载下，系统依然保持稳定运行  
- 🔧 模块支持：专为大规模模块化设计，优化处理能力

---

### [宣布 Rolldown-Vite | VoidZero](https://voidzero.dev/posts/announcing-rolldown-vite)

**原文标题**: [Announcing Rolldown-Vite | VoidZero](https://voidzero.dev/posts/announcing-rolldown-vite)

Rolldown-Vite 是一个基于 Rust 的新一代打包工具，旨在提升 Vite 的性能，现已达到与当前 Vite 版本的功能对等，可作为直接替代方案使用。早期测试显示，生产构建时间减少了 3 倍至 16 倍，内存使用量降低了高达 100 倍。未来，Rolldown 将成为 Vite 的默认打包工具。

- 🚀 **性能提升**：Rolldown-Vite 作为 Vite 的替代方案，可显著减少构建时间和内存使用。  
- 🔧 **简单替换**：通过修改 `package.json` 或使用 `overrides` 即可轻松切换到 `rolldown-vite`。  
- ⚙️ **兼容性优先**：已通过 Vite 生态系统 CI 测试，但部分高级用例可能存在兼容性问题。  
- 🛠️ **插件支持**：插件作者可立即测试其插件，部分可能需要调整以兼容 Rolldown。  
- 📊 **实际效果**：早期用户报告构建时间大幅减少，如 GitLab 从 2.5 分钟降至 40 秒。  
- 🔮 **未来计划**：包括开发全捆绑模式的开发服务器，并逐步将 Rolldown 合并到 Vite 主代码库。  
- 📢 **鼓励尝试**：用户可通过反馈帮助改进 Rolldown-Vite，问题可提交至专属仓库。

---

### [Node.js 通过 Amaro 1.0 迈向稳定的 TypeScript 支持](https://socket.dev/blog/node-js-moves-toward-stable-typescript-support-with-amaro-1-0)

**原文标题**: [Node.js Moves Toward Stable TypeScript Support with Amaro 1....](https://socket.dev/blog/node-js-moves-toward-stable-typescript-support-with-amaro-1-0)

pnpm 10.12 版本引入了全局虚拟存储和扩展版本目录功能，旨在提升安装效率并优化依赖管理。

- 🚀 pnpm 10.12.1 新增全局虚拟存储，显著加快安装速度  
- 📚 扩展版本目录功能，提供更灵活的依赖管理选项  
- ⏱ 发布于 2025 年 6 月 11 日，作者 Sarah Gooding

---

### [Gleam 语言](https://gleam.run/)

**原文标题**: [Gleam language](https://gleam.run/)

Gleam 是一种现代编程语言，结合了强大的类型系统、函数式编程表达能力和 Erlang 运行时的高并发与容错特性，提供简洁友好的语法和丰富的工具链支持。

- 💪 结合类型系统、函数式编程和 Erlang 运行时的高并发与容错能力  
- 🚀 运行于久经考验的 Erlang 虚拟机，支持百万级并发任务  
- ⚡ 内置编译器、构建工具、格式化器和包管理器，开箱即用  
- 🌐 兼容 BEAM 生态，可调用 Erlang/Elixir 代码，支持 JavaScript 编译  
- 🛡️ 无空值、无异常，提供清晰错误信息和实用类型系统  
- ✨ 社区友好包容，支持多元背景的开发者平等参与  
- 📦 轻松集成现有库，支持 TypeScript 类型定义生成  
- 📧 提供年度通讯订阅，保护用户隐私

---

### [Gleam JavaScript 性能提升 30%](https://gleam.run/news/gleam-javascript-gets-30-percent-faster/)

**原文标题**: [Gleam JavaScript gets 30% faster](https://gleam.run/news/gleam-javascript-gets-30-percent-faster/)

Gleam v1.11.0 发布，带来多项性能优化、语言功能增强和开发者体验改进。

- 🚀 Gleam 编译到 JavaScript 的性能提升 30%，得益于模式匹配优化为决策树结构  
- 📊 Lustre 前端框架的虚拟 DOM 性能显著提升（10 行数据从 142k → 208k ops/sec）  
- 🛠️ 新增 `assert` 语法，提供更丰富的测试失败诊断信息  
- 📂 引入 `dev/` 目录专门存放开发环境代码，与生产代码隔离  
- ⚠️ 编译器新增未使用返回值警告，帮助避免不可变编程常见错误  
- 🌐 JavaScript 运行时增强：支持 UTF-16/32 二进制数据解析  
- 📚 文档生成改进：保留类型变量原名，优化模块限定类型显示  
- 💡 语言服务器重大升级：新增常量支持、模式标签补全、变体生成等 7 项代码操作  
- 🐛 错误处理增强：模式匹配错误现在显示记录字段标签  
- 🖥️ 新增 Windows ARM64 预编译二进制支持  
- 🧩 编译器容错能力扩展至更多语法结构  
- 🤝 特别感谢核心贡献者 Giacomo Cavalieri 和 Surya Rose 的多个关键功能  

（注：保留了技术细节但大幅压缩了实现细节，突出版本亮点和开发者价值）

---

### [Immaculata.dev - Node.js 中原生的 HMR（技术解析）](https://immaculata.dev/blog/native-nodejs-hmr.html)

**原文标题**: [Immaculata.dev - HMR natively in Node.js (technical write up)](https://immaculata.dev/blog/native-nodejs-hmr.html)

Node.js 中原生实现 HMR（热模块替换）的技术方案，通过模块钩子和依赖树管理实现高效的状态更新。

- 🚀 **快速开发关键**：最小化状态丢弃，仅使更改的模块及其依赖失效，而非重启整个应用。  
- 🔄 **传统方案问题**：使用 `node:vm` 创建临时模块系统会导致逻辑重复、与原生模块系统隔离，形成“二等公民”模块。  
- 🛠️ **新方案改进**：通过 Node.js 原生 `node:module` 钩子实现热模块功能，避免重复加载和解析文件。  
- 📂 **文件树管理**：`FileTree` 类将文件加载到内存中，并通过 `.watch()` 监听更新，利用 `filesUpdated` 事件触发模块失效。  
- 🔗 **依赖追踪**：模块钩子在导入时注册依赖关系，父模块会随依赖更新自动失效，确保整个依赖树的最新状态。  
- ⚡ **版本控制**：文件修改时自动更新 `version`（时间戳），通过 URL 查询参数（如 `?ver=${file.version}`）实现缓存失效。  
- 💡 **代码示例**：结合 `FileTree` 和 `useTree` 钩子，实现模块按需重新执行（仅当失效时）。  
- ♻️ **资源清理**：依赖树支持发送 `moduleInvalidated` 事件，示例中用于销毁 Shiki 高亮器单例，避免内存泄漏。  
- 📜 **实际应用**：本站使用该方案动态更新语法高亮配置，无需重启进程。

---

### [宣布 Oxlint 1.0 | VoidZero](https://voidzero.dev/posts/announcing-oxlint-1-stable)

**原文标题**: [Announcing Oxlint 1.0 | VoidZero](https://voidzero.dev/posts/announcing-oxlint-1-stable)

Oxlint 1.0 稳定版正式发布，这是一款基于 Rust 的 JavaScript 和 TypeScript 代码检查工具，性能比 ESLint 快 50~100 倍，支持 500 多条 ESLint 规则，并被 Shopify、Airbnb 和梅赛德斯 - 奔驰等大型公司采用。

- 🚀 **性能提升**：Oxlint 在大型代码库中显著减少 CI 成本，实测每秒可检查约 10,000 个文件。
- 🏢 **企业应用**：Shopify、Airbnb 和梅赛德斯 - 奔驰等公司已采用 Oxlint，部分项目速度提升高达 97%。
- ⚡ **快速上手**：无需配置即可运行，支持 npm、pnpm、yarn、bun 和 deno 等多种包管理器。
- 🔧 **灵活配置**：支持通过 `.oxlintrc.json` 文件进行配置，兼容 ESLint v8 的扁平化配置格式。
- 🔄 **迁移工具**：提供 `oxlint-migrate` 和 `eslint-plugin-oxlint` 工具，便于从 ESLint 迁移。
- 📜 **规则覆盖**：包含 500 多条规则，涵盖 ESLint、TypeScript 及多个流行插件，并新增独特规则。
- 🖥️ **编辑器支持**：提供 VS Code、IntelliJ IDEA、WebStorm 和 Zed Editor 的扩展支持。
- 📊 **性能基准**：Oxlint 多线程模式下仅需 615.3 毫秒，而 ESLint 需要 33.481 秒。
- 🛣️ **未来计划**：支持自定义规则、持续性能优化和更细粒度的配置。
- 🙏 **社区贡献**：感谢 200 多位贡献者，特别鸣谢核心团队的成员。
- 💬 **加入社区**：通过 Discord、GitHub 和问题跟踪器提供反馈和参与讨论。

---

